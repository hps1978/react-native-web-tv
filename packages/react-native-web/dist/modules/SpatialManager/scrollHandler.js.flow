/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 * @format
 */

type SpatialScrollConfig = {
  edgeThresholdPx?: number,
  scrollThrottleMs?: number,
  smoothScrollEnabled?: boolean,
  scrollAnimationDurationMs?: number,
  scrollAnimationDurationMsVertical?: number,
  scrollAnimationDurationMsHorizontal?: number,
};
type ScrollState = {
  lastScrollAt: number,
  scrollAnimationFrame: number | null,
};

// API capability detection (one-time check at module load).
// TV platforms may lack modern APIs, so we detect and fall back gracefully.
// This avoids repeated try-catch blocks on every scroll operation.
const hasPerformance = typeof performance !== 'undefined' && typeof performance.now === 'function';
const hasRequestAnimationFrame = typeof requestAnimationFrame === 'function';
const hasGetComputedStyle = typeof window !== 'undefined' && typeof window.getComputedStyle === 'function';
const hasGetBoundingClientRect = typeof Element !== 'undefined' && Element.prototype.getBoundingClientRect !== undefined;
const hasScrollEndEvent = false;
//   typeof window !== 'undefined' &&
//   'onscrollend' in window;
declare var DEBUG_SCROLL: () => any;
const DEFAULT_SPATIAL_SCROLL_CONFIG: SpatialScrollConfig = {
  edgeThresholdPx: 128,
  scrollThrottleMs: 80,
  smoothScrollEnabled: true,
  scrollAnimationDurationMs: 0,
  scrollAnimationDurationMsVertical: 0,
  scrollAnimationDurationMsHorizontal: 0
};
declare function getCurrentTime(): number;
declare function scheduleAnimationFrame(callback: () => void): number;
declare function cancelScheduledFrame(frameId: number): void;
declare function animateScrollTo(scrollable: any, isVertical: boolean, nextOffset: number, durationMs: number, scrollState: ScrollState): any;
declare function getScrollDurationMs(scrollConfig: SpatialScrollConfig, isVertical: boolean): number;
declare function getScrollPosition(scrollable: any, isVertical: boolean, isWindowScroll: boolean): number; // Calculate if and how much to scroll to keep an element visible within its container.
// Uses edge threshold (edgeThresholdPx) to maintain padding from container boundaries.
// Returns: { needsScroll: boolean, scrollDelta: number (in pixels) }
declare function getAxisScrollDelta(targetRect: any, visibleContainerRect: any, axis: 'vertical' | 'horizontal'): {
  needsScroll: boolean,
  scrollDelta: number,
};
declare function waitForScrollSettle(scrollable: any, isVertical: boolean, isWindowScroll: boolean): Promise<void>;
declare function logScrollContainer(label: string, scrollableInfo: {
  scrollable: any,
  isWindowScroll: boolean,
}, elem: HTMLElement): void;
declare function scrollAxis(params: {
  scrollable: any,
  isWindowScroll: boolean,
  isVertical: boolean,
  scrollDelta: number,
  scrollConfig: SpatialScrollConfig,
  scrollState: ScrollState,
}): Promise<void>;
declare function findScrollableAncestor(elem: HTMLElement | null, direction: 'vertical' | 'horizontal'): HTMLElement | null;
declare function resolveScrollable(elem: HTMLElement, direction: 'vertical' | 'horizontal'): any; // Resolve element and container rectangles, clamping to viewport for accuracy.
// Important: bounding rects are viewport-relative, not document-relative.
// This avoids coordinate system mismatches when scrolling.
declare function resolveRects(scrollable: any, isWindowScroll: boolean, elem: HTMLElement): any;
declare function performScroll(scrollable: any, isVertical: boolean, scrollConfig: SpatialScrollConfig, scrollState: ScrollState, nextOffset: number, liveNextOffset: number): any;
declare function calculateNextOffset(currentOffset: number, scrollDelta: number, isWindowScroll: boolean, maxOffset: number): number;
type ReAcquireFocusOptions = {
  getCurrentFocus: () => {
    elem: HTMLElement | null,
    parentHasAutofocus: boolean,
  },
  onScrollRefocus: (params: {
    currentFocus: {
      elem: HTMLElement | null,
      parentHasAutofocus: boolean,
    },
    scrollContainer: HTMLElement | null,
  }) => void,
};

// Flag to track if the current scroll was initiated by SpatialManager
// Checked in the scrollend event to determine if focus reacquisition is needed
let isSpatialManagerInitiatedScroll: boolean = false;

// Debounce timer for fallback scroll handler (when scrollend not available)
let reacquireFocusTimeout: number | null = null;

/**
 * Mark that a scroll is being initiated by SpatialManager (for focus).
 * The flag will be checked in the scrollend event handler.
 */
declare function markSpatialManagerScroll(): void;
/**
 * Unmark SpatialManager-initiated scroll (called after scrollend event processes it).
 */
declare function unmarkSpatialManagerScroll(): void;
declare export function createScrollState(): ScrollState;
/**
 * Check if an element is visible within its scrollable container's viewport.
 * Used to determine if current focus is still in view after a scroll.
 */
declare export function isElementVisible(elem: HTMLElement, scrollContainer?: HTMLElement): boolean;
/**
 * Reacquire focus after app-initiated scroll.
 * If current focus is no longer visible, find the best candidate within the scrolled container.
 * This is called after the scroll settles (debounced).
 */
declare export function reacquireFocusAfterScroll(currentFocusElem: HTMLElement | null, scrollContainer: HTMLElement | null, options: ReAcquireFocusOptions): void;
/**
 * Setup global scroll listener to handle app-initiated scrolls.
 * Uses scrollend event when available (modern browsers), falls back to debounced scroll listener.
 *
 * Key pattern:
 * - SpatialManager marks its scrolls via isSpatialManagerInitiatedScroll
 * - Scroll event fires (either scrollend or debounced scroll)
 * - If SpatialManager initiated: skip reacquisition (we already have focus control)
 * - If app initiated: check if current focus is out of view and reacquire if needed
 *
 * This allows SpatialManager scrolls to be clean while gracefully handling app scrolls.
 */
declare export function setupAppInitiatedScrollHandler(container: HTMLElement | Document, options: ReAcquireFocusOptions): any;
/**
 * Scroll to align target element for AlignLeft mode.
 *
 * Behavior:
 * - ArrowRight: Align target's left edge to current focus X position (if scrollable space allows)
 * - ArrowLeft, ArrowUp, ArrowDown: Use default visibility behavior (keep in view)
 * - Vertical: Always uses default behavior regardless of direction
 *
 * Key insight: AlignLeft creates a fixed X position where focus appears to stay while
 * content scrolls left/right. But at content boundaries, we fall back to default behavior
 * to avoid breaking visual alignment of the original focus element.
 */
declare function scrollToAlignLeft(elem: HTMLElement | null, keyCode: string, currentElem: HTMLElement | null, scrollConfig: SpatialScrollConfig, scrollState: ScrollState): any; // Main entry point for scroll-on-focus logic.
// Dispatches to AlignLeft or default behavior based on focusMode.
// - AlignLeft: right aligns to current focus X, other directions use default
// - default: always use standard visibility behavior
declare export function maybeScrollOnFocus(elem: HTMLElement | null, keyCode: string, currentElem: HTMLElement | null, scrollConfig: SpatialScrollConfig, scrollState: ScrollState, focusMode?: 'AlignLeft' | 'default'): any;
export type { SpatialScrollConfig, ReAcquireFocusOptions };
export { DEFAULT_SPATIAL_SCROLL_CONFIG };